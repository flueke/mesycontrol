#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Author: Florian LÃ¼ke <florianlueke@gmx.net>

print("Start of setup.py")

from cx_Freeze import setup, Executable
from os.path import join as pjoin
import importlib
import glob
import hashlib
import os
import pathlib
import sys

CSD = '${CMAKE_CURRENT_SOURCE_DIR}'
CBD = '${CMAKE_CURRENT_BINARY_DIR}'
BD = '${CMAKE_BINARY_DIR}'

# Dependencies are automatically detected, but it might need
# fine tuning.

includes = list()
#maybe_includes = ['scipy.sparse.csgraph._validation', 'scipy.special._ufuncs_cxx']

#for mod in maybe_includes:
#    try:
#        importlib.import_module(mod)
#        includes.append(mod)
#    except ImportError:
#        pass

include_files = list()
maybe_include_files = [
    ## x86_64
    ##'/lib/x86_64-linux-gnu/libpng12.so.0',
    #'/usr/lib/x86_64-linux-gnu/libpng16.so.16',
    ##'/usr/lib/libblas.so.3',
    #'/usr/lib/x86_64-linux-gnu/blas/libblas.so.3',
    ##'/usr/lib/liblapack.so.3',
    #'/usr/lib/x86_64-linux-gnu/liblapack.so.3',
    #'/usr/lib/x86_64-linux-gnu/libaudio.so.2',
    #'/usr/lib/x86_64-linux-gnu/libgfortran.so.5',
    #'/usr/lib/x86_64-linux-gnu/libQtAssistantClient.so.4', 
    #'/usr/lib/x86_64-linux-gnu/libQtCLucene.so.4', 
    #'/usr/lib/x86_64-linux-gnu/libQtCore.so.4', 
    #'/usr/lib/x86_64-linux-gnu/libQtDBus.so.4', 
    #'/usr/lib/x86_64-linux-gnu/libQtDeclarative.so.4', 
    #'/usr/lib/x86_64-linux-gnu/libQtDesignerComponents.so.4', 
    #'/usr/lib/x86_64-linux-gnu/libQtDesigner.so.4', 
    #'/usr/lib/x86_64-linux-gnu/libQtGui.so.4', 
    #'/usr/lib/x86_64-linux-gnu/libQtHelp.so.4', 
    #'/usr/lib/x86_64-linux-gnu/libQtNetwork.so.4', 
    #'/usr/lib/x86_64-linux-gnu/libQtScript.so.4', 
    #'/usr/lib/x86_64-linux-gnu/libQtScriptTools.so.4', 
    #'/usr/lib/x86_64-linux-gnu/libQtSql.so.4', 
    #'/usr/lib/x86_64-linux-gnu/libQtSvg.so.4', 
    #'/usr/lib/x86_64-linux-gnu/libQtTest.so.4', 
    #'/usr/lib/x86_64-linux-gnu/libQtWebKit.so.4', 
    #'/usr/lib/x86_64-linux-gnu/libQtXmlPatterns.so.4', 
    #'/usr/lib/x86_64-linux-gnu/libQtXml.so.4', 

    ## x86
    #'/usr/lib/liblapack.so.3gf',
    #'/usr/lib/libblas/libblas.so.3gf',
    #'/usr/lib/i386-linux-gnu/libgfortran.so.3',
    ]

for fn in maybe_include_files:
    if os.path.exists(fn):
        tup = (fn, os.path.basename(fn))
        include_files.append(tup)

excluded_modules = [
        'email',
        'http',
        'matplotlib',
        'pdb',
        'pdb',
        'pydoc',
        'tkinter',
        'unittest',

        'PyQt4.uic.port_v3',
        'PyQt5',

        'pyqtgraph.examples',
        'pyqtgraph.exporters',
        'pyqtgraph.flowchart',
        'pyqtgraph.opengl',

        'PySide2.examples',
        'PySide2.Qt3DAnimation',
        'PySide2.Qt3DCore',
        'PySide2.Qt3DInput',
        'PySide2.Qt3DLogic',
        'PySide2.Qt3DRender',
        'PySide2.QtAxContainer',
        'PySide2.QtCharts',
        'PySide2.QtLocation',
        'PySide2.QtMultimediaWidgets',
        'PySide2.QtOpenGL',
        'PySide2.QtPrintSupport',
        'PySide2.QtQml',
        'PySide2.QtQuick',
        'PySide2.QtQuickWidgets',
        'PySide2.QtScxml',
        'PySide2.QtSensors',
        'PySide2.QtSql',
        'PySide2.QtSvg',
        'PySide2.QtTest',
        'PySide2.QtWebEngineWidgets',
        'PySide2.QtWebSockets',
        ]

build_options = dict(
      packages = ['mesycontrol', 'mesycontrol.ui'],

      # Excluding the python 3 uic and matplotlib. I can't get the latter to
      # work and I am not sure if it's actually needed.
      # Tkinter is excluded to make the build work if $DISPLAY is not set.
      excludes = excluded_modules,
      includes = includes,
      include_files = include_files,
      zip_includes = [ (pjoin(CBD, 'mesycontrol/mc_version.py'), 'mesycontrol/mc_version.py') ],
      # With zip_include_packages enabled PySide2.QtXml cannot be loaded at startup
      #zip_include_packages = ['PySide2', 'PySide2.QtXml', 'shiboken2'], 
      path = sys.path + [CSD],
      )

base_gui = 'Win32GUI' if sys.platform=='win32' else None

executables = [
    Executable(
        script=pjoin(CSD, 'mesycontrol_gui.py'),
        base=base_gui,
        initScript=pjoin(CSD, 'cxfreeze_init.py'),
        icon = pjoin(CSD, 'mesycontrol/resources/32x32.ico'),
        ),
]

version = '0.0' if sys.platform == 'win32' else '@GIT_VERSION@'

setup(name='@CMAKE_PROJECT_NAME@',
      version = version,
      description = 'mesycontrol',
      options = dict(build_exe = build_options),
      executables = executables,
      )

SharedLibSuffixPattern = '*.dll*' if sys.platform == 'win32' else '*.so*'

# Duplicate libs removal =======================================================

def calculate_file_hash(filename):
    def file_as_bytes(f):
        with f:
            return f.read()

    return hashlib.sha256(file_as_bytes(open(filename, 'rb')))

def group_identical_shared_libs(startPath):
    pattern = os.path.join(startPath, '**', SharedLibSuffixPattern)
    matches = glob.glob(pattern, recursive=True)
    groups = {}
    for filename in matches:
        fileHash = calculate_file_hash(filename).hexdigest()

        groups.setdefault(fileHash, list())
        groups[fileHash].append(filename)

    return groups

def remove_duplicate_libs():
    print(">>> Checking for duplicate shared libraries in install directory...")

    groupedLibs = group_identical_shared_libs(os.path.join(BD, "python-install"))
    # { hash -> list of lib paths hashing to the same hash }
    groupedLibs = { libHash: files for libHash, files in groupedLibs.items() if len(files) > 1 }

    for _, libPaths in groupedLibs.items():
        ## Find shortest path for file instances of the same library. minTuple structure is (pathLen, path).
        #minTuple = min(((len(libPath), libPath) for libPath in libPaths), key=lambda t: t[0])

        libBasename = os.path.basename(libPaths[0])

        # Walk the list of duplicates and group them by path depth: { depth -> [libPaths] }
        libsByPathDepth = {}

        for libPath in libPaths:
            depth = len(pathlib.PurePath(libPath).parts)
            libsByPathDepth.setdefault(depth, list())
            libsByPathDepth[depth].append(libPath)

        # Now pick the shortest depth (topmost path) and from the list of
        # candidate libs pick the one with the longest (meaning 'most
        # detailed') filename. E.g. instead of libpython.so we pick
        # libpython.so.0.1 as the file to keep.

        minDepth = min(libsByPathDepth.keys())
        candidates = libsByPathDepth[minDepth]
        libToKeep = max(candidates, key=lambda path: len(path))
        print(f"  lib={libBasename} -> keeping {libToKeep}")

        for libPath in (libPath for libPath in libPaths if libPath != libToKeep):
            print(f"    lib={libBasename} -> removing duplicate {libPath}")
            os.remove(libPath)

    print("<<< Done removing duplicate shared libraries")

remove_duplicate_libs()

# Excluded libs removal ========================================================

exclude_lib_patterns = [
    '*Qt53DAnimation*',
    '*Qt53DCore*',
    '*Qt53DExtras*',
    '*Qt53DInput*',
    '*Qt53DLogic*',
    '*Qt53DQuick*',
    '*Qt53DQuickAnimation*',
    '*Qt53DQuickExtras*',
    '*Qt53DQuickInput*',
    '*Qt53DQuickRender*',
    '*Qt53DQuickScene2D*',
    '*Qt53DRender*',
    '*Qt5Bluetooth*',
    '*Qt5Bodymovin*',
    '*Qt5Charts*',
    '*Qt5Concurrent*',
    '*Qt5Core*',
    '*Qt5DBus*',
    '*Qt5DataVisualization*',
    '*Qt5Designer*',
    '*Qt5DesignerComponents*',
    '*Qt5EglFSDeviceIntegration*',
    '*Qt5EglFsKmsSupport*',
    '*Qt5Gamepad*',
    '*Qt5Help*',
    '*Qt5Location*',
    '*Qt5Multimedia*',
    '*Qt5MultimediaGstTools*',
    '*Qt5MultimediaQuick*',
    '*Qt5MultimediaWidgets*',
    '*Qt5Network*',
    '*Qt5NetworkAuth*',
    '*Qt5Nfc*',
    '*Qt5OpenGL*',
    '*Qt5Pdf*',
    '*Qt5PdfWidgets*',
    '*Qt5Positioning*',
    '*Qt5PositioningQuick*',
    '*Qt5PrintSupport*',
    '*Qt5Purchasing*',
    '*Qt5Qml*',
    '*Qt5QmlModels*',
    '*Qt5QmlWorkerScript*',
    '*Qt5Quick*',
    '*Qt5Quick3D*',
    '*Qt5Quick3DAssetImport*',
    '*Qt5Quick3DRender*',
    '*Qt5Quick3DRuntimeRender*',
    '*Qt5Quick3DUtils*',
    '*Qt5QuickControls2*',
    '*Qt5QuickParticles*',
    '*Qt5QuickShapes*',
    '*Qt5QuickTemplates2*',
    '*Qt5QuickTest*',
    '*Qt5QuickWidgets*',
    '*Qt5RemoteObjects*',
    '*Qt5Script*',
    '*Qt5ScriptTools*',
    '*Qt5Scxml*',
    '*Qt5Sensors*',
    '*Qt5SerialBus*',
    '*Qt5SerialPort*',
    '*Qt5Sql*',
    '*Qt5Svg*',
    '*Qt5Test*',
    '*Qt5TextToSpeech*',
    '*Qt5VirtualKeyboard*',
    '*Qt5WaylandClient*',
    '*Qt5WaylandCompositor*',
    '*Qt5WebChannel*',
    '*Qt5WebEngine*',
    '*Qt5WebEngineCore*',
    '*Qt5WebEngineWidgets*',
    '*Qt5WebSockets*',
    '*Qt5WebView*',
    '*Qt5X11Extras*',
    '*Qt5XcbQpa*',
    '*Qt5Xml*',
    '*Qt5XmlPatterns*',
        ]

shared_lib_suffix = '.dll' if sys.platform == 'win32' else '.so*'

print(">>> Removing excluded libs")

for l in exclude_lib_patterns:
    pattern = os.path.join(BD, "python-install", "**", l + SharedLibSuffixPattern)
    globbed = glob.glob(pattern, recursive=True)

    for f in globbed:
        print(f"  Removing excluded lib {f}")
        os.remove(f)

print("<<< Done removing excluded libs")

print("End of setup.py")
