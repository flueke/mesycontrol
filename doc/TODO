* Track config sources. Ask about unsaved changes.
* Improve Command:
  - get first/all failed subcommand(s) from CommandGroups
  - add __str__ to Commands

* How to handle the RC setting? For MHV4 enabling/disabling RC can be dangerous.
  -> User can easily change it
  -> Also store it in the DeviceConfig (or in MRCConfig?)

* Server:
  - exception safety
  - timeouts
  - add max connections feature
  - add rc_changed notification (bus, dev, rc_new)
  - scanbus(3) shuts down the mrc connection cause of a timeout. fix this!
    the command 'sc 3' results in only one line of output: 'ERROR!' no other
    output is generated.

* Scripting:
  - Standalone vs. running inside the GUI
  - Wrapper documentation

STARTED - DeviceDescription: add conversion to human readable units (<unit label="mA" factor="1000.0")
DONE - DeviceDescription: add value range to parameters (min, max). Make sure input in SI units is rounded correctly
  - DeviceDescription: add version detection (MSFC-16)
  - DeviceDescription: add a flag to mark system descriptions
  - DeviceDescription: add a way to copy a description
  - DeviceDescription: refactor to DeviceProfile or something like that to
    avoid confusion with the textual description that's in the DeviceConfig
DONE  - DeviceConfigXML: use attributes instead of nested tags for simple stuff (makes the XML file shorter)
  - DeviceConfigXML: add DTD (used for verification)


* GUI plan:
class SomeTreeWidget:
    def on_item_doubleclicked(self, item):
        if not has_window_for(item.device):
            widget = DeviceWidget(item.device)
            register_device_widget(widget)
        raise_and_show(get_window_for(item.device))


class DeviceWidget:
    def __init__(self, device):
        title = "%s"*4 %(device.name, device.mrc.name, device.bus, device.dev)

        # create device table model, restore settings
        device_table_model = DeviceTableModel(device)
        self.device_table_view.setModel(device_table_model)

        # create log view model, add loggers, set settings
        log_view_model     = LogViewModel()
        log_view_model.addLogger(device.log)
        log_view_model.addLogger(device.mrc.log, logging.WARNING)
        log_view_model.setOptions(Settings.getLastOptionsForThisLogViewFromStorage())
        self.log_view.setModel(log_view_model)

        device_panel = panel_factory(device, self)
        self.panel_frame.addWidget(device_panel)
        self.log_view.addLogger(device_panel.log, logging.INFO)

class DeviceTableModel(QAbstractTableModel):
    def __init__(self, device):
        self.device = device
        self.device.sig_foo.connect(self.on_foo)
        self.device.sig_bar.connect(self.on_bar)

class LogViewModel:
    def add_logger(self, logger):
        self._loggers.append(logger)

    def add_filter(self, a_filter):
        self._filters.append(a_filter)

def panel_factory(device, parent=None):
    if device.idc == 17:
        return MHV4Panel(device, parent)

class MHV4Panel(QtGui.QWidget):
    def __init__(self, mhv4, parent=None):
        super(MHV4Panel, self).__init__(parent)


* Config plan:
MRCConnection -> MRCModel -> DeviceModel    -> DeviceDescription
                          -> MRCConfig      -> DeviceConfig
                                                            -> ParameterConfig


Use cases fuer configs:
    - Config erstellen aus bestehender Verbindung
      -> ConnectionConfigs fuer verwendete MRCs, DeviceConfigs, non-default DeviceDescriptions

    - Config fuer ein Device
      -> ConnectionConfig + DeviceConfig

    - Setup laden
      -> find connection by name
         if not found:
             find connection by params
         if not found:
             create connection

         update connection name
         for each device:
             if needed: set device description!
             update device name
             load params

    - observe modifications:
        object names (connection, device)
        object descriptions
        connection params
        manual set of device params
        param aliases (ParameterConfig!)
        DeviceDescription+ParameterDescription:
            can change set of params to be stored in the description.
            changes polling, unit conversion, etc.
        DeviceDescription: can be a system description. if modified this needs
        to be copied and included in the the config!

Wo Configs halten?
An zentraler Stelle? Lookups auf z.B. ParameterConfig.alias muessen immer ueber
zentrale stelle gehen. Observer muessen sich an zentrale stelle wenden.

In den Models? Wie dann Verbindung zum Config-Objekt halten? weakrefs in den
subconfigs? qobject parent/child? Was wenn kein Config objekt exisitiert
(manuelle verbindung)? -> Config sollte immer existieren. Im Zweifel halt neu
erstellen (z.B. auch wenn ein neues GerÃ¤t dazukommt).

Wann ParameterConfig.value aktualisieren? -> Wenn user es will (z.B. load setup
        -> modify stuff -> save setup -> neuer wert drin)
  braucht's das? im moment wird alles neu erstellt. allerdings werden aliase auch nicht gespeichert...


doppelclick auf mrc -> name gaendert:
def on_edit_finished(self, txt):
    self.mrc.name = txt
    # emits name changed which could be observed by the config object.
    # -> MRCConfig.name = name -> emit modified(True) -> Config observes and sets modified(True)
    # -> GUI observes and draws a '*' and asks the user about saving on disconnect
    # after saving the config to a file -> config.modified = False -> GUI
    # observes and removes '*'

=> MRCConfig observes MRCConnection and MRCModel
=> DeviceConfig observes DeviceModel (bleh, DeviceModel does not have aliases for parameters)
=> DeviceModel needs access to ParameterConfig (alias, value)

==================================================
class ScanbusResult(object):
    def __init__(self, bus):
        self.bus  = bus
        self.data = [(0, 0) for i in range(16)]

    def has_device(self, address):
        return self.data[address][0] > 0

    def has_address_conflict(self, address):
        return self.data[address][1] not in (0, 1)

def test_idc_change():
    scanbus_result = ScanbusResult(bus=0)
    scanbus_result.data[0] = (17, 1)

    mrc = MRCModel()
    mrc.set_scanbus_result(scanbus_result)

* Application Model
setup1
    mrc1
        mrcconfig1          # What's in here? Connection config and name?
        mrcmodel1
        dev1
            devmodel1
            devconfig1
            devdescr1

        dev2
            devconfig2
            devdescr2

    mrc2
        dev1
        dev2

setup2
    mrc1
        mrcconfig1_2        # Conflicts with mrcconfig1. Update: The connection information is the same
                            # as it's the same MRC. Name and description might differ though.
        mrcmodel1
        dev1_2
            devmodel1
            devconfig1_2    # conflicts with devconfig1
            devdescr1_2     # conflicts with devdescr1

        dev3
            devconfig3
            devdescr3


* HW Model
mrcmodel1
    devmodel1

* HW/SW Connection
mrcbackend1
    mrcconnection1
    mrcmodel1
    mrccontroller1

mrcconnection1  -> mrcmodel1        <- view, controller
               <-  mrccontroller1   <- controller

* Setup Model
setup1
    mrcconfig1
        devconfig1
    devdescr1

=== Application Model ===
== Hardware Model ==
MRCModel
    DeviceModel

Read access for the application, write access for a controller to propagate
hardware changes into the application.

== Setup Model ==
Setup
    MRCConfig
        DeviceConfig
            [DeviceDescription]

== Application view on the models ==
Setup
    MRC
        MRCModel
        MRCController
        MRCConfig
        Device
            DeviceModel
            DeviceConfig
            DeviceDescription
            DeviceController(?)

MRC combines the "passive" model, the controller and a config.
Device combines controller, config and devicemodel. Both config and device may
be empty (no config for a device or no device for a config).
DeviceDescription is usually a system description but can be set from the setup
or by the user.

== Process ==
* On manual connect:
    Create MRCConnection
    Create MRCModel
    Create MRCController
    connect connection, controller and model

    
== MRCController and DeviceController 
Starts and keeps track of async operations.

controller.read_parameter(bus=0, dev=1, address=32, started=self._read_started, stopped=self._read_stopped)

-> Controller creates a read_parameter message and asks the connection to send
it. At a later point the connection calls back on the controller with the
result. The controller then modifies the DeviceModel if needed -> GUI gets
updated.
The controller should know about outstanding commands and should keep track of
failed commands.
On error a flag on the DeviceModel could be set.
The user should be able to specify a callback to be called on request completion.

Higher level:
Device has DeviceModel and DeviceConfig. User issues a "load config" action via context menu.
-> Multiple parameters have to be loaded.
-> Progress should be reported
-> Command class needed!

controller.load_config(bus=0, dev=1, config=self.config,
    started=self._load_started, stopped=self._load_stopped, progress_changed=self._load_progress_changed)

xxx: From an application view loading a config needs more action that just
applying the config values to the device: Device.config needs to be updated.
The new config might have a different Setup root than the old config. -> Node
needs to move in a tree view.

dev1.config is config1 from setup1
action: load config2 from setup2 into dev1
-> set dev1.config to config2
-> config2 has a different root than config1 (new: setup2, old: setup1)
-> config loader to actually apply the values
-> UI needs move the node representing dev1.


* scanbus result handling
  if device_model.idc != result.idc:
      device_model.idc = result.idc # device_model emits idc_changed
      device reacts on device_model.idc_changed and triggers a refresh (asks
      the controller to refresh the device memory).
      Other parts of the GUI have to react aswell: an open widget for the old
      idc should display an error as it is not intended for the new idc.
      

== object ownership ==
* SetupModel is a root
  SetupModel owns child configs

* MRCModel owns child DeviceModels (and creates them on scanbus_result)

* Setup
  owns MRC instances

* MRC
    owns MRCModel
    owns MRCController
    ref on MRCConfig
  
* Device
    ref on DeviceModel (it's owned by the parent MRCModel)
    ref on DeviceConfig (it's owned by the the containing setup) XXX: what if there's no setup?

=== Ablauf scanbus ===
- gui scanbus click handler:
  node.ref.scanbus(1)
  node.ref.scanbus(2)

- MRC.scanbus(self, bus):
  self.controller.scanbus(bus)

- MesycontrolMRCController.scanbus(self, bus):
  self.connection.send_message(Message('request_scanbus', bus=bus),
    self._handle_response)

- MesycontrolMRCController.handle_response(self, request, response):
  if response.is_scanbus_response():
      self.mrc_model.set_scanbus_data(response.bus, response.data)

- MRCModel.set_scanbus_result(self, bus, data):
  # Bus logic here. In this example a new device is added.
  _add_device() -> device_added.emit()

- MRC receives device_added from MRCModel
  in the handler:
  device_controller = DeviceController(self.mrc_controller, device_model)
  device_config     = self.mrc_config.get_device_config(
        device_model.bus, device_model.address)
  device_description = self.mrc_config.get_device_description(device_model.bus,
        device_model.address, device_model.idc)
  device = Device(device_model, device_config, device_description, device_controller)
  self.devices.add_device(device)
*** Ende Ablauf scanbus ***

=== Ablauf manual connect ===
- gui -> MRCConfig mrc_config
  if has_connection(mrc_config):
      display_error_message("Connection exists")
      
  mrc_controller = factory(mrc_config)
  mrc_model      = MRCModel()
  mrc_controller.set_model(mrc_model)
  mrc            = MRC(mrc_model, mrc_controller, mrc_config)
  mrc.connect()

-> MRC.connect(self):
   return self.controller.connect()


===== Tue Jul 22 12:49:40 CEST 2014 =====
* Commands:
  - Connect, Disconnect (MRC)
  - WaitForReady (mrc and device versions)
  - Refresh (mrc (scanbus) and device (all params) versions)
  - ReadParameter, SetParameter, ReadMirror, SetMirror, Copy, SetRC, Reset
  - LoadSetup, LoadConfig, SaveSetup, SaveConfig

* Structure
  - Hardware Model:
    MRCModel with DeviceModel children. Read-only view of the hardware.
    MRCModel has a controller which handles requests and their replies. One
    controller per MRCModel.
  - Controller:
    Gateway between MRCConnection and MRCModel.
    Keeps a queue of pending requests. Receives replies and updates the model accordingly.
    The interface is callback based: read_parameter(bus, dev, par, response_handler).
    The response_handler is invoked once the response has been received and the
    model has been updated. It is passed a Response object.
    Response objects comply to an interface: is_error_response(), get_result()
    A controller needs to be implemented for different connection types. E.g. MesycontrolController, VirtualController, ...
    MesycontrolController just invokes MRCConnection.send_message() with the
    appropriate Message and passing itself as the callback. Once the response
    is received the model is updated and the original response handler is
    invoked.
    The controller also has to deal with notifications and connection state changes and update the model accordingly.

  - Commands:
    Implemented in terms of the controller interface only. E.g.:
    class ReadParameter(Command):
        def start():
            self._cmd_id = self.mrc.controller.read_parameter(self.bus, self.dev, self.addr, self._handle_response)
        def _handle_response(self, response):
            self.response = response
        def get_result(self):
            if self.response.is_error_response():
                raise ErrorResponse(self.response)
            return response.get_result()

    class Refresh(SequentialCommandGroup):
        def __init__(self, device):
            self.device = device
            for i in range(256):
                self.add(ReadParameter(self.device, i))

        def start(self):
            super(Refresh, self).start() # Runs each of the subcommands

    class Connect(Command):
       def __init__(self, mrc):
          self.mrc = mrc

       def start():
          if not self.mrc.controller.is_connected():
              self.mrc.controller.state_changed.connect(self._controller_state_changed)
              # More state change listening here...
              self.mrc.controller.connect() # Calls self.connection.connect()
           else:
               self.finished(True) # success! :)

            


  - Problems:
    * How to cancel commands once they've been started?
        From the controllers perspective: on_disconnect():
            for (request_message, response_handler) in self.queue:
                response_handler(ErrorResponse("disconnected"))
            self.queue.clear()

        From the command perspective:
            If not yet started and cancel() is called: Mark the command as finished and canceled -> that's all.
            If it has been started: controller.cancel(something that identifies this request)
            Solution: the controllers methods must return a handle that identifies
            a particular request. This allows canceling of request and thus
            canceling of commands.

    * Who starts commands?
    -> The client that created the command. Queues can easily be implemented.
    Those queues can also take commands that are not MRC or Device related.
    Global command registry is needed for very high level commands like
    LoadSetup and SaveSetup.


==== Steps to take when a new connection should be made ====
* HW Model
    - create connection using the factory
    - create MRCModel
    - create MRCController using connection and model
    - register MRCModel
    - connect

* App Model
  Who creates the MRC object?
    - create MRC using MRCModel (no Config)
    - register MRC


===== Plan Tue Aug  5 10:11:10 CEST 2014 =====
- HW vs. Config:


Use cases:
- Connect to an MRC
  * Creates a new connection using the supplied information (serial device, baud rate, ...)
  * connect
  * scan both busses
  -> user gets a tree with connected devices as leaves

- List and edit device parameters
  * Table view of the device parameters
  * refresh memory / mirror memory / single parameter
  * set param to value

- Save device config to file
  * Dump device memory to file
  * No connection information stored in the file
- Load device config from file
- Save setup to file
- Load setup from file

#def observe_property_change(prop_name):
#    def the_decorator(method):
#        def inner(self, *args, **kwargs):
#            old_prop_value = getattr(self, prop_name)
#            method(self, *args, **kwargs)
#            new_prop_value = getattr(self, prop_name)
#            if old_prop_value != new_prop_value:
#                print "emitting!"
#                self.changed.emit()
#        return inner
#    return the_decorator
#
#    @observe_property_change('name')
#    def set_name(self, name):
#        self._name = name

