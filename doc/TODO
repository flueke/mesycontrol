* enumerate com ports
* Source layout, package building, installation need improvement
* Track config sources. Ask about unsaved changes.
* Improve Command:
  - get first/all failed subcommand(s) from CommandGroups
  - add __str__ to Commands

* Virtual connections:
  - load setup to virtual connections
  - create new virtual, add/remove devices from virtual

* How to handle the RC setting? For MHV4 enabling/disabling RC can be dangerous.
  -> User can easily change it
  -> Also store it in the DeviceConfig (or in MRCConfig?)

* Server:
  - exception safety
  - timeouts
  - add max connections feature
  - add rc_changed notification (bus, dev, rc_new)
  - scanbus(3) shuts down the mrc connection cause of a timeout. fix this!
    the command 'sc 3' results in only one line of output: 'ERROR!' no other
    output is generated.

* Scripting:
  - Standalone vs. running inside the GUI
  - Wrapper documentation

* build system
  - fix cxfreeze prefix issue on windows
  - fix slow performance on windows

STARTED - DeviceDescription: add conversion to human readable units (<unit label="mA" factor="1000.0")
DONE - DeviceDescription: add value range to parameters (min, max). Make sure input in SI units is rounded correctly
  - DeviceDescription: add version detection (MSFC-16)
  - DeviceDescription: add a flag to mark system descriptions
  - DeviceDescription: add a way to copy a description
  - DeviceConfig: add a way to store MRC connection info in the configuration
  - DeviceConfigXML: use attributes instead of nested tags for simple stuff (makes the XML file shorter)
  - DeviceConfigXML: add DTD (used for verification)


* GUI plan:
class SomeTreeWidget:
    def on_item_doubleclicked(self, item):
        if not has_window_for(item.device):
            widget = DeviceWidget(item.device)
            register_device_widget(widget)
        raise_and_show(get_window_for(item.device))


class DeviceWidget:
    def __init__(self, device):
        title = "%s"*4 %(device.name, device.mrc.name, device.bus, device.dev)

        # create device table model, restore settings
        device_table_model = DeviceTableModel(device)
        self.device_table_view.setModel(device_table_model)

        # create log view model, add loggers, set settings
        log_view_model     = LogViewModel()
        log_view_model.addLogger(device.log)
        log_view_model.addLogger(device.mrc.log, logging.WARNING)
        log_view_model.setOptions(Settings.getLastOptionsForThisLogViewFromStorage())
        self.log_view.setModel(log_view_model)

        device_panel = panel_factory(device, self)
        self.panel_frame.addWidget(device_panel)
        self.log_view.addLogger(device_panel.log, logging.INFO)

class DeviceTableModel(QAbstractTableModel):
    def __init__(self, device):
        self.device = device
        self.device.sig_foo.connect(self.on_foo)
        self.device.sig_bar.connect(self.on_bar)

class LogViewModel:
    def add_logger(self, logger):
        self._loggers.append(logger)

    def add_filter(self, a_filter):
        self._filters.append(a_filter)

def panel_factory(device, parent=None):
    if device.idc == 17:
        return MHV4Panel(device, parent)

class MHV4Panel(QtGui.QWidget):
    def __init__(self, mhv4, parent=None):
        super(MHV4Panel, self).__init__(parent)


* Config plan:
MRCConnection -> MRCModel -> DeviceModel    -> DeviceDescription
                          -> MRCConfig      -> DeviceConfig
                                                            -> ParameterConfig


Use cases fuer configs:
    - Config erstellen aus bestehender Verbindung
      -> ConnectionConfigs fuer verwendete MRCs, DeviceConfigs, non-default DeviceDescriptions

    - Config fuer ein Device
      -> ConnectionConfig + DeviceConfig

    - Setup laden
      -> find connection by name
         if not found:
             find connection by params
         if not found:
             create connection

         update connection name
         for each device:
             if needed: set device description!
             update device name
             load params

    - observe modifications:
        object names (connection, device)
        object descriptions
        connection params
        manual set of device params
        param aliases (ParameterConfig!)
        DeviceDescription+ParameterDescription:
            can change set of params to be stored in the description.
            changes polling, unit conversion, etc.
        DeviceDescription: can be a system description. if modified this needs
        to be copied and included in the the config!

Wo Configs halten?
An zentraler Stelle? Lookups auf z.B. ParameterConfig.alias muessen immer ueber
zentrale stelle gehen. Observer muessen sich an zentrale stelle wenden.

In den Models? Wie dann Verbindung zum Config-Objekt halten? weakrefs in den
subconfigs? qobject parent/child? Was wenn kein Config objekt exisitiert
(manuelle verbindung)? -> Config sollte immer existieren. Im Zweifel halt neu
erstellen (z.B. auch wenn ein neues GerÃ¤t dazukommt).

Wann ParameterConfig.value aktualisieren? -> Wenn user es will (z.B. load setup
        -> modify stuff -> save setup -> neuer wert drin)
  braucht's das? im moment wird alles neu erstellt. allerdings werden aliase auch nicht gespeichert...


doppelclick auf mrc -> name gaendert:
def on_edit_finished(self, txt):
    self.mrc.name = txt
    # emits name changed which could be observed by the config object.
    # -> MRCConfig.name = name -> emit modified(True) -> Config observes and sets modified(True)
    # -> GUI observes and draws a '*' and asks the user about saving on disconnect
    # after saving the config to a file -> config.modified = False -> GUI
    # observes and removes '*'

=> MRCConfig observes MRCConnection and MRCModel
=> DeviceConfig observes DeviceModel (bleh, DeviceModel does not have aliases for parameters)
=> DeviceModel needs access to ParameterConfig (alias, value)
