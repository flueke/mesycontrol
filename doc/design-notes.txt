Use cases
=========
* Connect and interact with MRCs
* View an MRCs bus configuration
* View and edit device parameters using device specific GUIs and/or a generic
  table view
* Save device state to config file
* Load config onto device. Notify user on errors. Allow retries.
* Save complete device tree (may include multiple mrc connections) to a config
  file ("Setup")
* Load a Setup from file.
  For each MRC in the Setup:
   - Connect to the MRC
   - Read the bus configuration and compare it to the Setup.
   - Abort if bus configuration does not match. Multiple cases here:
     additional devices present, missing devices, conflicting devices.
   - Load device configs
* Apply changes done to the hardware to the config
* Save single device config to file
* Load single device config from file
* Save all device configs and the corresponding mrc information to a file
  (Setup)
* Load setup from file
* Re(apply) setups and device configs
* On application start restore the previous state: open and load the last
  saved setup, open device windows.
* Offline creation and editing of devices
  The gui should allow to add and remove devices from/to a setup. Specific
  GUIs and the generic table view should also work (limitations are ok and
  expected as there will be no feedback from the hardware)
* Logging of MRC communication and events
  Logging should be able to differentiate between polling and non-polling
  reads.

GUI elements
============
MenuBar             menubar         global and context dependend actions
ToolBar             toolbar         global and context dependend actions
SetupTreeView       dock
MessageView         dock            Messages intended for the end-user
LogView             dock            Python logging output
ServerLogView       dock            Server output if running a local server
Device GUIs         mdi windows
Device TableViews   mdi windows
Interactive Windows mdi windows     device specific, e.g. histogram

Terms
=====
* Parameter Config
  address, value
* Device Config
  idc, bus, address, [rc], parameter configs
* MRC Config
  connection type and parameters
* Setup
  A setup is a collection of MRC configurations which in turn contain device
  configurations.
  Right now it can also contain "flat" device configs. This means device
  configs that are not children of any MRC Config.

Facts
=====
* Serial communication is the major bottleneck. This means deciding when to
  issue which requests is important for GUI responsiveness.
* Periodic execution of certain commands is needed: polling of changing
  parameters and status flags, scanbus commands to detect changes on the bus.
* The basic hardware model is relatively simple: a tree with an MRC at the
  root, two busses and up to 16 devices per bus.
  - MRC data: None
  - Bus data: bus number
  - Device data:
    bus
    address
    idc
    256 memory cells
    256 mirror cells
    RC state

* Additional bus data: Bus not terminated
  This is currently not directly reported by the MRC but instead address
  conflicts are seen at every address (exception: no conflict is shown for the
  STM-16 in my setup). In a newer firmware version this might be reported.
  -> Can't distinguish a termination problem from address conflicts.

* Address conflicts:
  - Reported for each device by the scanbus command
  - Reported for device specific commands like read, set, rc_on, etc...
  -> Getting an address conflict error for a specific command could trigger a
  scan of the bus to determine other devices involved in the conflict
* One main problem is: How to handle changes to the bus configuration?
* The mesycontrol protocol does not work well with multiple clients as polling
  of parameters is done client-side. This means multiple clients would poll
  the same data and thus overload the serial communication. Clients would
  basically be stuck.
  Solutions:
  - Make clients talk to each other and decide on a common set of
    parameters to poll.
    => too complex
  - Perform server-side polling: clients tell the server which parameters
    they're interested in. The server then performs the poll if no commands
    are pending (meaning the serial connection is idle).
    => Server work needed: add polling logic, keep track of sets of parameters
    per client, interrupt polling if an interactive command arrives and resume
    once no more commands are pending.

Possible bus changes
====================
* No device present -> 1.1 device present
                    -> 1.2 device present + address conflict

* device present    -> 2.1 no device present
                    -> 2.2 device present + address conflict
                    -> 2.3 device idc changed

* device present +  -> 3.1 no device present
  address conflict  -> 3.2 device present
                    -> 3.3 device idc changed
                    -> 3.4 device idc changed + address conflict

1.1 Allow the user to add the device to the current setup. Allow user
    interaction with the device.
1.2 User has to fix the conflict. No interaction with the device possible.

2.1 Notify the user about a missing device, i.e. mark the device somehow.
    Saving the last known device state to a config should still be possible.
    -> scanbus is performed, device is not present anymore, create a snapshot
    of the current device state, remove the device from the model and notify
    observers
2.2 User has to fix the conflict. Saving the current device state should be
    possible, other device interactions must be blocked.
2.3 IDC change: Mark the device. Saving the last known state of the old device
    should be possible. The user must decide whether to keep the old device
    (conflict between setup and hardware state remains) or replace it with the
    newly found device (conflict solved).

3.1 Transition from error state to normal state. Handling depends on whether
    a device with the specified address is in the Setup. If no device in the
    setup -> no action needed. Else mark the device as missing as in 2.1. If a
    device state is known it should be possible to save it.
3.2 Address conflict resolved. Refresh device state.
3.3 As 2.3 but an old device state might not be known.
3.4 Error state remains the same but device IDC changed. The device is still
    not usable.

