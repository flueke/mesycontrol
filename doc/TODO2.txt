==========================================================
===== mesycontrol plan Wed Aug 13 12:22:38 CEST 2014 =====
==========================================================

* Use cases and how to implement them. Focus on interaction of objects!

* Define hardware, config and setup models and their interactions
  - When is a config for a device created? Which values does it contain? When
    and how is the config modified? Who keeps track of the filename if any?
  - Is the hw_model, app_model, config separation good? Keep it? Modify it?
    How does support for offline editing work with this?

    -> Offline editing:
    The hw_model uses ???

  - How and where to implement device specific functionality? E.g. MHV4:
    disableAllChannels().

    This functionality should be available to the GUI and to scripts -> Command
    pattern needed but I don't want to implement MHV4.disable_all_channels()
    and a DisableAllChannelsCommand.

    Another approach: cmd = mhv4.disable_all_channels(); cmd.start()
    But this is exactly opposite to how the Device class behaves right now.

    -> Implementation inside the command:
    class DisableAllChannels(Command):
      def __init__(self, device):
        assert device.idc in get_valid_idcs()
        for i in range(4):
          self.add.SetParameter(self.device, i+4, 0)

* Define what views on the data are needed and what they should show.
  - connection state, errors, busy, silent mode, write access
  - hw/config state: differences, errors due to values being out of range (e.g.
    mhv4 cropping set_voltage if the current voltage limit is lower than the
    requested voltage. order matters here!)
  - address conflict handling
  - handling of changing IDCs!

* What should be shown in logging windows (per mrc, per device, ...)?

# FIXME: bug somewhere in Command or SequentialCommandGroup: stopped()
# is emitted before started() if the command group is empty.  instead
# of config_builder.started.connect(pd.exec_); config_builder.start() I
# had to use a singleshot timer to start the command as otherwise the
# pd would never close.
#
#def on_started():
#    print "==== started"

#def on_stopped():
#    print "==== stopped"

#def on_progress_changed(cur, tot):
#    print "==== progress_changed", cur, tot

#config_builder.stopped.connect(on_stopped)
#config_builder.started.connect(on_started)
#config_builder.progress_changed.connect(on_progress_changed)
